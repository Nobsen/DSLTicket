/*
 * generated by Xtext
 */
package org.nordakademie.mwi.tickets.validation

import org.eclipse.xtext.validation.Check
import com.google.inject.Inject
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.nordakademie.mwi.tickets.tickets.Field
import org.nordakademie.mwi.tickets.tickets.Status
import org.nordakademie.mwi.tickets.tickets.TicketsPackage
import org.nordakademie.mwi.tickets.tickets.Flow
import org.nordakademie.mwi.tickets.tickets.TicketCategory
import org.nordakademie.mwi.tickets.tickets.Role
import java.util.HashSet
import org.nordakademie.mwi.tickets.tickets.RolePermission
import org.nordakademie.mwi.tickets.tickets.TicketField

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class TicketsValidator extends AbstractTicketsValidator {

	public static val INVALID_NAME = 'invalidName';
	public static val INVALID_FIELD = 'invalidField';
	public static val INVALID_NO_OF_STATUS = 'invalidNoOfStatus';
	public static val INVALID_PERMISSION = 'invalidPermission';

	@Inject
	IQualifiedNameProvider qualifiedNameProvider

	@Check
	def checkFieldNameNotEmpty(Field field) {
		if (field.label == null || field.label.trim.empty) {
			error('Label must not be empty', TicketsPackage.Literals.FIELD__LABEL, INVALID_NAME)
		}
	}

	@Check
	def checkStateNameNotEmpty(Status status) {
		if (status.description == null || status.description.trim.empty) {
			error('Description must not be empty', TicketsPackage.Literals.STATUS__DESCRIPTION, INVALID_NAME)
		}
	}

	@Check
	def checkTicketCategoryNameNotEmpty(TicketCategory ticketCategory) {
		if (ticketCategory.description == null || ticketCategory.description.trim.empty) {
			error('Description must not be empty', TicketsPackage.Literals.TICKET_CATEGORY__DESCRIPTION, INVALID_NAME)
		}
	}

	@Check
	def checkRoleNameNotEmpty(Role role) {
		if (role.description == null || role.description.trim.empty) {
			error('Description must not be empty', TicketsPackage.Literals.ROLE__DESCRIPTION, INVALID_NAME)
		}
	}

	@Check
	def samesFieldsInCategroy(TicketCategory ticketCategory) {
		val fields = new HashSet<String>();
		val dublicates = new HashSet<String>();

		for (field : ticketCategory.ticketFields) {
			if (!fields.add(field.field.name)) {
				dublicates.add(field.field.name);
			}
		}

		if (!dublicates.empty) {
			error('The ticketCategory contains duplicate entries in fields: ' + dublicates.join(', '),
				TicketsPackage.Literals.TICKET_CATEGORY__NAME, INVALID_FIELD)
		};
	}

	@Check
	def sameStatesInFlow(Flow flow) {
		val fields = new HashSet<String>();
		val dublicates = new HashSet<String>();

		for (status : flow.states) {
			if (!fields.add(status.name)) {
				dublicates.add(status.name);
			}
		}

		if (!dublicates.empty) {
			error('The flow contains duplicate entries in states: ' + dublicates.join(', '),
				TicketsPackage.Literals.FLOW__NAME, INVALID_FIELD)
		};
	}

	@Check
	def samePermissionInField(RolePermission rolePermission) {
		val permissions = new HashSet<String>();
		val dublicates = new HashSet<String>();

		for (fieldPermission : rolePermission.permissions) {
			if (!permissions.add(fieldPermission.toString)) {
				dublicates.add(fieldPermission.toString);
			}
		}

		if (!dublicates.empty) {
			error('The Field contains duplicate entries in permissions: ' + dublicates.join(', '),
				TicketsPackage.Literals.ROLE_PERMISSION__FIELD, INVALID_PERMISSION)
		};
	}

	@Check
	def sameFieldsInRole(Role role) {
		val fields = new HashSet<String>();
		val dublicates = new HashSet<String>();

		for (rolePermission : role.rolepermissions) {
			if (!fields.add(rolePermission.field.name)) {
				dublicates.add(rolePermission.field.name);
			}
		}

		if (!dublicates.empty) {
			error('The Role contains duplicate entries in Fields: ' + dublicates.join(', '),
				TicketsPackage.Literals.ROLE__NAME, INVALID_PERMISSION)
		};
	}

	@Check
	def checkMoreThanOneStatusInFlow(Flow flow) {
		if (flow.states.length < 2) {
			error('There must be at least 2 Status in the flow', TicketsPackage.Literals.FLOW__NAME,
				INVALID_NO_OF_STATUS)
		}
	}
	
	@Check
	def checkAtleastOneFieldOnList(TicketCategory ticketCategory) {
		var oneOnList = false;
		
		for (field : ticketCategory.ticketFields) {
			if (!field.notOnList) {
				oneOnList = true;
			}
		}
		
		if (!oneOnList) warning('At least one field should be displayed on the list view', TicketsPackage.Literals.TICKET_CATEGORY__NAME);
	}
}
